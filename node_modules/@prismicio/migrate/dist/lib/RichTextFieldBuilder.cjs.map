{"version":3,"file":"RichTextFieldBuilder.cjs","sources":["../../../src/lib/RichTextFieldBuilder.ts"],"sourcesContent":["import type {\n\tInjectMigrationSpecificTypes,\n\tRTInlineNode,\n\tRTLinkNode,\n\tRTNode,\n\tRTTextNode,\n\tRichTextField,\n} from \"@prismicio/client\"\n\nimport { PrismicRichTextError } from \"../errors/PrismicRichTextError\"\n\n/**\n * Omits keys from a type, distributing the operation over a union.\n *\n * Taken from the `type-fest` package.\n *\n * @see https://github.com/sindresorhus/type-fest/blob/8a45ba048767aaffcebc7d190172d814a739feb0/source/distributed-omit.d.ts\n */\ntype DistributedOmit<\n\tObjectType,\n\tKeyType extends keyof ObjectType,\n> = ObjectType extends unknown ? Omit<ObjectType, KeyType> : never\n\n/**\n * An inline node without its `start` and `end` properties.\n */\nexport type RTPartialInlineNode = DistributedOmit<RTInlineNode, \"start\" | \"end\">\n\nexport class RichTextFieldBuilder {\n\t#nodes: InjectMigrationSpecificTypes<RTNode>[] = []\n\n\tget #last(): InjectMigrationSpecificTypes<RTNode> | undefined {\n\t\treturn this.#nodes[this.#nodes.length - 1]\n\t}\n\n\tappendNode(node: InjectMigrationSpecificTypes<RTNode>): void {\n\t\tthis.cleanupLast()\n\n\t\tthis.#nodes.push(node)\n\t}\n\n\tappendTextNode(\n\t\ttype: RTTextNode[\"type\"],\n\t\tdirection: \"ltr\" | \"rtl\" = \"ltr\",\n\t): void {\n\t\tthis.appendNode({\n\t\t\ttype,\n\t\t\ttext: \"\",\n\t\t\tspans: [],\n\t\t\tdirection,\n\t\t})\n\t}\n\n\tappendSpan(span: InjectMigrationSpecificTypes<RTInlineNode>): void\n\tappendSpan(\n\t\tpartialSpan: InjectMigrationSpecificTypes<RTPartialInlineNode>,\n\t\tlength: number,\n\t): void\n\tappendSpan(\n\t\tspanOrPartialSpan: InjectMigrationSpecificTypes<\n\t\t\tRTInlineNode | RTPartialInlineNode\n\t\t>,\n\t\tlength?: number,\n\t): void {\n\t\tif (!this.isTextNode(this.#last)) {\n\t\t\tthrow new PrismicRichTextError(\"Cannot add span to non-text last node\")\n\t\t}\n\n\t\tlet span: InjectMigrationSpecificTypes<RTInlineNode>\n\t\tif (\"start\" in spanOrPartialSpan && \"end\" in spanOrPartialSpan) {\n\t\t\tspan = spanOrPartialSpan\n\t\t} else {\n\t\t\tconst lastLength = this.#last.text.length\n\n\t\t\tspan = {\n\t\t\t\t...spanOrPartialSpan,\n\t\t\t\tstart: lastLength,\n\t\t\t\tend: lastLength + length!,\n\t\t\t}\n\t\t}\n\n\t\tlet lastIdenticalSpanIndex = -1\n\t\tfor (let i = this.#last.spans.length - 1; i >= 0; i--) {\n\t\t\tconst lastSpan = this.#last.spans[i]\n\n\t\t\tif (span.type === \"strong\" || span.type === \"em\") {\n\t\t\t\tif (lastSpan.type === span.type) {\n\t\t\t\t\tlastIdenticalSpanIndex = i\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t} else if (span.type === \"label\") {\n\t\t\t\tif (\n\t\t\t\t\tlastSpan.type === \"label\" &&\n\t\t\t\t\tlastSpan.data.label === span.data.label\n\t\t\t\t) {\n\t\t\t\t\tlastIdenticalSpanIndex = i\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t} else if (span.type === \"hyperlink\") {\n\t\t\t\tif (lastSpan.type === \"hyperlink\") {\n\t\t\t\t\t// Check that all data fields are the same. Since it's not a\n\t\t\t\t\t// deep equal operation, this doesn't guarantee a perfect\n\t\t\t\t\t// match with content relationship.\n\t\t\t\t\tconst isSameLink =\n\t\t\t\t\t\ttypeof span.data === \"object\" && typeof lastSpan.data === \"object\"\n\t\t\t\t\t\t\t? (\n\t\t\t\t\t\t\t\t\tObject.entries(span.data) as [\n\t\t\t\t\t\t\t\t\t\tkeyof RTLinkNode[\"data\"],\n\t\t\t\t\t\t\t\t\t\tunknown,\n\t\t\t\t\t\t\t\t\t][]\n\t\t\t\t\t\t\t\t).every(\n\t\t\t\t\t\t\t\t\t([key, value]) =>\n\t\t\t\t\t\t\t\t\t\tlastSpan.data?.[key as keyof (typeof lastSpan)[\"data\"]] ===\n\t\t\t\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t: span.data === lastSpan.data\n\n\t\t\t\t\tif (isSameLink) {\n\t\t\t\t\t\tlastIdenticalSpanIndex = i\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Ignore empty spans.\n\t\tif (span.start === span.end) {\n\t\t\treturn\n\t\t}\n\n\t\t// Prefer to extend the last span of the same type end\n\t\t// position if it ends at the start of the new span.\n\t\tif (this.#last.spans[lastIdenticalSpanIndex]?.end === span.start) {\n\t\t\tthis.#last.spans[lastIdenticalSpanIndex].end = span.end\n\t\t} else {\n\t\t\tthis.#last.spans.push(span)\n\t\t}\n\t}\n\n\tappendText(text: string): void {\n\t\tif (!this.isTextNode(this.#last)) {\n\t\t\tthrow new PrismicRichTextError(\"Cannot append text to non-text last node\")\n\t\t}\n\n\t\tif (this.#last.text) {\n\t\t\tthis.#last.text += text\n\t\t} else {\n\t\t\tthis.#last.text = text.trimStart()\n\t\t}\n\t}\n\n\tbuild(): RichTextField {\n\t\t// Ensure that the last text node is trimmed.\n\t\tthis.cleanupLast()\n\n\t\t// Because `RichTextField` is defined as a non-empty\n\t\t// array, we have to cast `RTNode[]` to `RichTextField`.\n\t\treturn this.#nodes as RichTextField\n\t}\n\n\t/**\n\t * Cleans up the current last node.\n\t */\n\tprivate cleanupLast(): void {\n\t\tif (this.isTextNode(this.#last)) {\n\t\t\tthis.#last.text = this.#last.text.trimEnd()\n\t\t}\n\t}\n\n\t/**\n\t * Determines if a node is a text node.\n\t *\n\t * @param node - rich text node to check.\n\t *\n\t * @returns `true` if `node` is a text node, `false` otherwise.\n\t */\n\tprivate isTextNode(\n\t\tnode?: InjectMigrationSpecificTypes<RTNode>,\n\t): node is InjectMigrationSpecificTypes<RTTextNode> {\n\t\treturn !!node && node.type !== \"image\" && node.type !== \"embed\"\n\t}\n}\n"],"names":["PrismicRichTextError","_a"],"mappings":"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"}