import { RichTextNodeType, LinkType } from "@prismicio/client";
const getAllowedNodeTypes = (model) => {
  var _a;
  const allowedNodeTypes = [];
  if (model.config) {
    if ("multi" in model.config && model.config.multi) {
      allowedNodeTypes.push(...model.config.multi.split(","));
    } else if ("single" in model.config && model.config.single) {
      allowedNodeTypes.push(...model.config.single.split(","));
    }
    if ((_a = model.config.labels) == null ? void 0 : _a.length) {
      allowedNodeTypes.push("label");
    }
  }
  return allowedNodeTypes;
};
const filterImageNode = (node, model) => {
  var _a, _b;
  if (!((_a = model.config) == null ? void 0 : _a.allowTargetBlank) && ((_b = node.linkTo) == null ? void 0 : _b.link_type) === LinkType.Web) {
    return {
      ...node,
      linkTo: {
        ...node.linkTo,
        target: void 0
      }
    };
  }
  return node;
};
const filterTextNode = (node, model, allowedNodeTypes) => {
  var _a, _b, _c;
  const filteredNode = {
    ...node,
    spans: []
  };
  for (let i = 0; i < node.spans.length; i++) {
    const span = node.spans[i];
    if (allowedNodeTypes.includes(span.type)) {
      if (span.type === RichTextNodeType.hyperlink) {
        if (!((_a = model.config) == null ? void 0 : _a.allowTargetBlank) && span.data.link_type === LinkType.Web) {
          filteredNode.spans.push({
            ...span,
            data: {
              ...span.data,
              target: void 0
            }
          });
        } else {
          filteredNode.spans.push(span);
        }
      } else if (span.type === RichTextNodeType.label) {
        if ((_c = (_b = model.config) == null ? void 0 : _b.labels) == null ? void 0 : _c.includes(span.data.label)) {
          filteredNode.spans.push(span);
        }
      } else {
        filteredNode.spans.push(span);
      }
    }
  }
  return filteredNode;
};
const filterRichTextField = (richTextField, model) => {
  const nodes = [];
  const allowedNodeTypes = getAllowedNodeTypes(model);
  for (
    let i = 0;
    // Only process the first node if it's a "single" node rich text type
    i < (model.config && "multi" in model.config ? richTextField.length : 1);
    i++
  ) {
    const node = richTextField[i];
    if (allowedNodeTypes.includes(node.type)) {
      if (node.type === RichTextNodeType.image) {
        nodes.push(filterImageNode(node, model));
      } else if (node.type === RichTextNodeType.embed) {
        nodes.push(node);
      } else {
        nodes.push(filterTextNode(node, model, allowedNodeTypes));
      }
    }
  }
  return nodes;
};
export {
  filterRichTextField
};
//# sourceMappingURL=filterRichTextField.js.map
