"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const client = require("@prismicio/client");
const hastUtilToString = require("hast-util-to-string");
const unistUtilVisit = require("unist-util-visit");
const PrismicRichTextSerializerError = require("../errors/PrismicRichTextSerializerError.cjs");
const RichTextFieldBuilder = require("./RichTextFieldBuilder.cjs");
const hastSerializerHelpers = require("./hastSerializerHelpers.cjs");
const DEFAULT_SERIALIZER = {
  h1: "heading1",
  h2: "heading2",
  h3: "heading3",
  h4: "heading4",
  h5: "heading5",
  h6: "heading6",
  p: "paragraph",
  pre: "preformatted",
  strong: "strong",
  em: "em",
  li: ({ context }) => context.listType === "group-o-list-item" ? "o-list-item" : "list-item",
  ul: "group-list-item",
  ol: "group-o-list-item",
  img: "image",
  iframe: "embed",
  a: "hyperlink"
};
const VFILE_RULE = "failed-to-serialize-node";
const VFILE_SOURCE = "prismic";
const hastToRichText = (tree, file, config) => {
  const builder = new RichTextFieldBuilder.RichTextFieldBuilder();
  const serializer = {
    ...DEFAULT_SERIALIZER,
    ...config == null ? void 0 : config.serializer
  };
  let lastRTTextNodeType = client.RichTextNodeType.paragraph;
  let lastListType = void 0;
  unistUtilVisit.visit(tree, (node) => {
    if (node.type === "element") {
      if (node.tagName === "br") {
        try {
          builder.appendText("\n");
        } catch (error) {
        }
      }
      let serializerOrShorthand;
      if (node.matchesSerializer && node.matchesSerializer in serializer) {
        serializerOrShorthand = serializer[node.matchesSerializer];
      } else if (node.tagName in serializer) {
        serializerOrShorthand = serializer[node.tagName];
      } else {
        return;
      }
      let shorthand;
      if (typeof serializerOrShorthand === "function") {
        const shorthandOrNode = serializerOrShorthand({
          node,
          context: { listType: lastListType }
        });
        if (!shorthandOrNode) {
          return;
        } else if (typeof shorthandOrNode === "object" && "type" in shorthandOrNode) {
          switch (shorthandOrNode.type) {
            case client.RichTextNodeType.strong:
            case client.RichTextNodeType.em:
            case client.RichTextNodeType.label:
            case client.RichTextNodeType.hyperlink: {
              const length = hastUtilToString.toString(node).trimEnd().length;
              try {
                builder.appendSpan(shorthandOrNode, length);
              } catch (error) {
                builder.appendTextNode(lastRTTextNodeType, config == null ? void 0 : config.direction);
                builder.appendSpan(shorthandOrNode, length);
              }
              return;
            }
            case client.RichTextNodeType.image:
            case client.RichTextNodeType.embed:
              builder.appendNode(shorthandOrNode);
              return;
            default:
              lastRTTextNodeType = shorthandOrNode.type;
              builder.appendNode(shorthandOrNode);
              return;
          }
        }
        shorthand = shorthandOrNode;
      } else {
        shorthand = serializerOrShorthand;
      }
      let match;
      if (typeof shorthand === "string") {
        match = { type: shorthand };
      } else {
        match = { type: client.RichTextNodeType.label, data: shorthand };
      }
      try {
        switch (match.type) {
          case client.RichTextNodeType.heading1:
          case client.RichTextNodeType.heading2:
          case client.RichTextNodeType.heading3:
          case client.RichTextNodeType.heading4:
          case client.RichTextNodeType.heading5:
          case client.RichTextNodeType.heading6:
          case client.RichTextNodeType.paragraph:
          case client.RichTextNodeType.preformatted:
          case client.RichTextNodeType.listItem:
          case client.RichTextNodeType.oListItem:
            lastRTTextNodeType = match.type;
            builder.appendTextNode(match.type, config == null ? void 0 : config.direction);
            break;
          case client.RichTextNodeType.list:
          case client.RichTextNodeType.oList:
            lastListType = match.type;
            break;
          case client.RichTextNodeType.image:
            builder.appendNode(hastSerializerHelpers.serializeImage(node));
            break;
          case client.RichTextNodeType.embed:
            builder.appendNode(hastSerializerHelpers.serializeEmbed(node));
            break;
          case client.RichTextNodeType.strong:
          case client.RichTextNodeType.em:
          case client.RichTextNodeType.label:
          case client.RichTextNodeType.hyperlink: {
            const span = hastSerializerHelpers.serializeSpan(node, match);
            const length = hastUtilToString.toString(node).trimEnd().length;
            try {
              builder.appendSpan(span, length);
            } catch (error) {
              builder.appendTextNode(lastRTTextNodeType, config == null ? void 0 : config.direction);
              builder.appendSpan(span, length);
            }
            break;
          }
          default:
            throw new Error(`Unknown rich text node type: \`${match.type}\``);
        }
      } catch (error) {
        if (error instanceof PrismicRichTextSerializerError.PrismicRichTextSerializerError) {
          file.message(error.message, {
            cause: error,
            place: node.position,
            ruleId: VFILE_RULE,
            source: VFILE_SOURCE
          });
          return;
        }
        throw error;
      }
    } else if (node.type === "text") {
      if (!(node.value.replace(/[ \t\n\f\r]/g, "") === "")) {
        try {
          builder.appendText(node.value);
        } catch (error) {
          builder.appendTextNode(lastRTTextNodeType, config == null ? void 0 : config.direction);
          builder.appendText(node.value);
        }
      }
    }
  });
  return builder.build();
};
exports.hastToRichText = hastToRichText;
//# sourceMappingURL=hastToRichText.cjs.map
