"use strict";
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var _nodes, _RichTextFieldBuilder_instances, last_get;
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const PrismicRichTextError = require("../errors/PrismicRichTextError.cjs");
class RichTextFieldBuilder {
  constructor() {
    __privateAdd(this, _RichTextFieldBuilder_instances);
    __privateAdd(this, _nodes, []);
  }
  appendNode(node) {
    this.cleanupLast();
    __privateGet(this, _nodes).push(node);
  }
  appendTextNode(type, direction = "ltr") {
    this.appendNode({
      type,
      text: "",
      spans: [],
      direction
    });
  }
  appendSpan(spanOrPartialSpan, length) {
    var _a;
    if (!this.isTextNode(__privateGet(this, _RichTextFieldBuilder_instances, last_get))) {
      throw new PrismicRichTextError.PrismicRichTextError("Cannot add span to non-text last node");
    }
    let span;
    if ("start" in spanOrPartialSpan && "end" in spanOrPartialSpan) {
      span = spanOrPartialSpan;
    } else {
      const lastLength = __privateGet(this, _RichTextFieldBuilder_instances, last_get).text.length;
      span = {
        ...spanOrPartialSpan,
        start: lastLength,
        end: lastLength + length
      };
    }
    let lastIdenticalSpanIndex = -1;
    for (let i = __privateGet(this, _RichTextFieldBuilder_instances, last_get).spans.length - 1; i >= 0; i--) {
      const lastSpan = __privateGet(this, _RichTextFieldBuilder_instances, last_get).spans[i];
      if (span.type === "strong" || span.type === "em") {
        if (lastSpan.type === span.type) {
          lastIdenticalSpanIndex = i;
          break;
        }
      } else if (span.type === "label") {
        if (lastSpan.type === "label" && lastSpan.data.label === span.data.label) {
          lastIdenticalSpanIndex = i;
          break;
        }
      } else if (span.type === "hyperlink") {
        if (lastSpan.type === "hyperlink") {
          const isSameLink = typeof span.data === "object" && typeof lastSpan.data === "object" ? Object.entries(span.data).every(([key, value]) => {
            var _a2;
            return ((_a2 = lastSpan.data) == null ? void 0 : _a2[key]) === value;
          }) : span.data === lastSpan.data;
          if (isSameLink) {
            lastIdenticalSpanIndex = i;
            break;
          }
        }
      }
    }
    if (span.start === span.end) {
      return;
    }
    if (((_a = __privateGet(this, _RichTextFieldBuilder_instances, last_get).spans[lastIdenticalSpanIndex]) == null ? void 0 : _a.end) === span.start) {
      __privateGet(this, _RichTextFieldBuilder_instances, last_get).spans[lastIdenticalSpanIndex].end = span.end;
    } else {
      __privateGet(this, _RichTextFieldBuilder_instances, last_get).spans.push(span);
    }
  }
  appendText(text) {
    if (!this.isTextNode(__privateGet(this, _RichTextFieldBuilder_instances, last_get))) {
      throw new PrismicRichTextError.PrismicRichTextError("Cannot append text to non-text last node");
    }
    if (__privateGet(this, _RichTextFieldBuilder_instances, last_get).text) {
      __privateGet(this, _RichTextFieldBuilder_instances, last_get).text += text;
    } else {
      __privateGet(this, _RichTextFieldBuilder_instances, last_get).text = text.trimStart();
    }
  }
  build() {
    this.cleanupLast();
    return __privateGet(this, _nodes);
  }
  /**
   * Cleans up the current last node.
   */
  cleanupLast() {
    if (this.isTextNode(__privateGet(this, _RichTextFieldBuilder_instances, last_get))) {
      __privateGet(this, _RichTextFieldBuilder_instances, last_get).text = __privateGet(this, _RichTextFieldBuilder_instances, last_get).text.trimEnd();
    }
  }
  /**
   * Determines if a node is a text node.
   *
   * @param node - rich text node to check.
   *
   * @returns `true` if `node` is a text node, `false` otherwise.
   */
  isTextNode(node) {
    return !!node && node.type !== "image" && node.type !== "embed";
  }
}
_nodes = new WeakMap();
_RichTextFieldBuilder_instances = new WeakSet();
last_get = function() {
  return __privateGet(this, _nodes)[__privateGet(this, _nodes).length - 1];
};
exports.RichTextFieldBuilder = RichTextFieldBuilder;
//# sourceMappingURL=RichTextFieldBuilder.cjs.map
