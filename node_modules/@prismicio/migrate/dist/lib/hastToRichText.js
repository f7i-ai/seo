import { RichTextNodeType } from "@prismicio/client";
import { toString } from "hast-util-to-string";
import { visit } from "unist-util-visit";
import { PrismicRichTextSerializerError } from "../errors/PrismicRichTextSerializerError.js";
import { RichTextFieldBuilder } from "./RichTextFieldBuilder.js";
import { serializeSpan, serializeEmbed, serializeImage } from "./hastSerializerHelpers.js";
const DEFAULT_SERIALIZER = {
  h1: "heading1",
  h2: "heading2",
  h3: "heading3",
  h4: "heading4",
  h5: "heading5",
  h6: "heading6",
  p: "paragraph",
  pre: "preformatted",
  strong: "strong",
  em: "em",
  li: ({ context }) => context.listType === "group-o-list-item" ? "o-list-item" : "list-item",
  ul: "group-list-item",
  ol: "group-o-list-item",
  img: "image",
  iframe: "embed",
  a: "hyperlink"
};
const VFILE_RULE = "failed-to-serialize-node";
const VFILE_SOURCE = "prismic";
const hastToRichText = (tree, file, config) => {
  const builder = new RichTextFieldBuilder();
  const serializer = {
    ...DEFAULT_SERIALIZER,
    ...config == null ? void 0 : config.serializer
  };
  let lastRTTextNodeType = RichTextNodeType.paragraph;
  let lastListType = void 0;
  visit(tree, (node) => {
    if (node.type === "element") {
      if (node.tagName === "br") {
        try {
          builder.appendText("\n");
        } catch (error) {
        }
      }
      let serializerOrShorthand;
      if (node.matchesSerializer && node.matchesSerializer in serializer) {
        serializerOrShorthand = serializer[node.matchesSerializer];
      } else if (node.tagName in serializer) {
        serializerOrShorthand = serializer[node.tagName];
      } else {
        return;
      }
      let shorthand;
      if (typeof serializerOrShorthand === "function") {
        const shorthandOrNode = serializerOrShorthand({
          node,
          context: { listType: lastListType }
        });
        if (!shorthandOrNode) {
          return;
        } else if (typeof shorthandOrNode === "object" && "type" in shorthandOrNode) {
          switch (shorthandOrNode.type) {
            case RichTextNodeType.strong:
            case RichTextNodeType.em:
            case RichTextNodeType.label:
            case RichTextNodeType.hyperlink: {
              const length = toString(node).trimEnd().length;
              try {
                builder.appendSpan(shorthandOrNode, length);
              } catch (error) {
                builder.appendTextNode(lastRTTextNodeType, config == null ? void 0 : config.direction);
                builder.appendSpan(shorthandOrNode, length);
              }
              return;
            }
            case RichTextNodeType.image:
            case RichTextNodeType.embed:
              builder.appendNode(shorthandOrNode);
              return;
            default:
              lastRTTextNodeType = shorthandOrNode.type;
              builder.appendNode(shorthandOrNode);
              return;
          }
        }
        shorthand = shorthandOrNode;
      } else {
        shorthand = serializerOrShorthand;
      }
      let match;
      if (typeof shorthand === "string") {
        match = { type: shorthand };
      } else {
        match = { type: RichTextNodeType.label, data: shorthand };
      }
      try {
        switch (match.type) {
          case RichTextNodeType.heading1:
          case RichTextNodeType.heading2:
          case RichTextNodeType.heading3:
          case RichTextNodeType.heading4:
          case RichTextNodeType.heading5:
          case RichTextNodeType.heading6:
          case RichTextNodeType.paragraph:
          case RichTextNodeType.preformatted:
          case RichTextNodeType.listItem:
          case RichTextNodeType.oListItem:
            lastRTTextNodeType = match.type;
            builder.appendTextNode(match.type, config == null ? void 0 : config.direction);
            break;
          case RichTextNodeType.list:
          case RichTextNodeType.oList:
            lastListType = match.type;
            break;
          case RichTextNodeType.image:
            builder.appendNode(serializeImage(node));
            break;
          case RichTextNodeType.embed:
            builder.appendNode(serializeEmbed(node));
            break;
          case RichTextNodeType.strong:
          case RichTextNodeType.em:
          case RichTextNodeType.label:
          case RichTextNodeType.hyperlink: {
            const span = serializeSpan(node, match);
            const length = toString(node).trimEnd().length;
            try {
              builder.appendSpan(span, length);
            } catch (error) {
              builder.appendTextNode(lastRTTextNodeType, config == null ? void 0 : config.direction);
              builder.appendSpan(span, length);
            }
            break;
          }
          default:
            throw new Error(`Unknown rich text node type: \`${match.type}\``);
        }
      } catch (error) {
        if (error instanceof PrismicRichTextSerializerError) {
          file.message(error.message, {
            cause: error,
            place: node.position,
            ruleId: VFILE_RULE,
            source: VFILE_SOURCE
          });
          return;
        }
        throw error;
      }
    } else if (node.type === "text") {
      if (!(node.value.replace(/[ \t\n\f\r]/g, "") === "")) {
        try {
          builder.appendText(node.value);
        } catch (error) {
          builder.appendTextNode(lastRTTextNodeType, config == null ? void 0 : config.direction);
          builder.appendText(node.value);
        }
      }
    }
  });
  return builder.build();
};
export {
  hastToRichText
};
//# sourceMappingURL=hastToRichText.js.map
