{"version":3,"file":"hastToRichText.js","sources":["../../../src/lib/hastToRichText.ts"],"sourcesContent":["import type {\n\tRTBlockNode,\n\tRTInlineNode,\n\tRTLabelNode,\n\tRTTextNode,\n\tRichTextField,\n} from \"@prismicio/client\"\nimport { RichTextNodeType } from \"@prismicio/client\"\nimport type { Element, Root } from \"hast\"\nimport { toString } from \"hast-util-to-string\"\nimport { visit } from \"unist-util-visit\"\nimport type { VFile } from \"vfile\"\n\nimport type {\n\tRichTextHTMLMapSerializer,\n\tRichTextHTMLMapSerializerFunction,\n\tRichTextHTMLMapSerializerShorthand,\n} from \"../types\"\n\nimport { PrismicRichTextSerializerError } from \"../errors/PrismicRichTextSerializerError\"\n\nimport { RichTextFieldBuilder } from \"./RichTextFieldBuilder\"\nimport {\n\tserializeEmbed,\n\tserializeImage,\n\tserializeSpan,\n} from \"./hastSerializerHelpers\"\n\n/**\n * Pick keys from a type, distributing the operation over a union.\n *\n * Taken from the `type-fest` package.\n *\n * @see https://github.com/sindresorhus/type-fest/blob/8a45ba048767aaffcebc7d190172d814a739feb0/source/distributed-pick.d.ts\n */\ntype DistributedPick<\n\tObjectType,\n\tKeyType extends keyof ObjectType,\n> = ObjectType extends unknown ? Pick<ObjectType, KeyType> : never\n\nconst DEFAULT_SERIALIZER: RichTextHTMLMapSerializer = {\n\th1: \"heading1\",\n\th2: \"heading2\",\n\th3: \"heading3\",\n\th4: \"heading4\",\n\th5: \"heading5\",\n\th6: \"heading6\",\n\tp: \"paragraph\",\n\tpre: \"preformatted\",\n\tstrong: \"strong\",\n\tem: \"em\",\n\tli: ({ context }) =>\n\t\tcontext.listType === \"group-o-list-item\" ? \"o-list-item\" : \"list-item\",\n\tul: \"group-list-item\",\n\tol: \"group-o-list-item\",\n\timg: \"image\",\n\tiframe: \"embed\",\n\ta: \"hyperlink\",\n}\n\nconst VFILE_RULE = \"failed-to-serialize-node\"\nconst VFILE_SOURCE = \"prismic\"\n\n/**\n * Configuration that determines the output of `toRichText`.\n */\nexport type HASTToRichTextConfig = {\n\t/**\n\t * An optional HTML to rich text serializer. Will be merged with the default\n\t * HTML to rich text serializer.\n\t */\n\tserializer?: RichTextHTMLMapSerializer\n\n\t/**\n\t * Whether or not the text processed should be marked as right-to-left.\n\t *\n\t * @defaultValue `false`\n\t */\n\tdirection?: \"ltr\" | \"rtl\"\n}\n\n/**\n * Transfor a hast tree to a rich text field.\n *\n * @param tree - The hast tree to transform.\n * @param file - The vfile to attach warnings to.\n * @param config - Configuration that determines the output of the function.\n *\n * @returns The rich text field equivalent of the provided hast tree.\n */\nexport const hastToRichText = (\n\ttree: Root | Element,\n\tfile: VFile,\n\tconfig?: HASTToRichTextConfig,\n): RichTextField => {\n\tconst builder = new RichTextFieldBuilder()\n\n\t// Merge the default serializer with the user-provided one.\n\tconst serializer = {\n\t\t...DEFAULT_SERIALIZER,\n\t\t...config?.serializer,\n\t}\n\n\t// Keep track of the last text node type to append text nodes to in\n\t// case of an image or an embed node is present inside a paragraph.\n\tlet lastRTTextNodeType: RTTextNode[\"type\"] = RichTextNodeType.paragraph\n\n\t// Keep track of the last list type to know whether we need to append\n\t// `list-item` or `o-list-item` nodes.\n\tlet lastListType: \"group-list-item\" | \"group-o-list-item\" | undefined =\n\t\tundefined\n\n\tvisit(tree, (node) => {\n\t\tif (node.type === \"element\") {\n\t\t\t// Transforms line break elements to line breaks\n\t\t\tif (node.tagName === \"br\") {\n\t\t\t\ttry {\n\t\t\t\t\tbuilder.appendText(\"\\n\")\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// noop\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Resolves the serializer responsible for the current node.\n\t\t\tlet serializerOrShorthand:\n\t\t\t\t| RichTextHTMLMapSerializerShorthand\n\t\t\t\t| RichTextHTMLMapSerializerFunction\n\n\t\t\t// We give priority to CSS selectors over tag names.\n\t\t\tif (node.matchesSerializer && node.matchesSerializer in serializer) {\n\t\t\t\tserializerOrShorthand = serializer[node.matchesSerializer]\n\t\t\t} else if (node.tagName in serializer) {\n\t\t\t\tserializerOrShorthand = serializer[node.tagName]\n\t\t\t} else {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tlet shorthand: RichTextHTMLMapSerializerShorthand\n\t\t\tif (typeof serializerOrShorthand === \"function\") {\n\t\t\t\tconst shorthandOrNode = serializerOrShorthand({\n\t\t\t\t\tnode,\n\t\t\t\t\tcontext: { listType: lastListType },\n\t\t\t\t})\n\n\t\t\t\tif (!shorthandOrNode) {\n\t\t\t\t\t// Exit on unhandled node.\n\t\t\t\t\treturn\n\t\t\t\t} else if (\n\t\t\t\t\ttypeof shorthandOrNode === \"object\" &&\n\t\t\t\t\t\"type\" in shorthandOrNode\n\t\t\t\t) {\n\t\t\t\t\t// When the serializer returns a rich text node, we append it and return.\n\t\t\t\t\tswitch (shorthandOrNode.type) {\n\t\t\t\t\t\tcase RichTextNodeType.strong:\n\t\t\t\t\t\tcase RichTextNodeType.em:\n\t\t\t\t\t\tcase RichTextNodeType.label:\n\t\t\t\t\t\tcase RichTextNodeType.hyperlink: {\n\t\t\t\t\t\t\tconst length = toString(node).trimEnd().length\n\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tbuilder.appendSpan(shorthandOrNode, length)\n\t\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\t\t// Happens when we extract an image/embed node inside an RTTextNode and that\n\t\t\t\t\t\t\t\t// the next children is a span. The last RT node type is then an image/embed\n\t\t\t\t\t\t\t\t// node, so we need to resume a new RT text node.\n\t\t\t\t\t\t\t\tbuilder.appendTextNode(lastRTTextNodeType, config?.direction)\n\t\t\t\t\t\t\t\tbuilder.appendSpan(shorthandOrNode, length)\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcase RichTextNodeType.image:\n\t\t\t\t\t\tcase RichTextNodeType.embed:\n\t\t\t\t\t\t\tbuilder.appendNode(shorthandOrNode)\n\n\t\t\t\t\t\t\treturn\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tlastRTTextNodeType = shorthandOrNode.type\n\t\t\t\t\t\t\tbuilder.appendNode(shorthandOrNode)\n\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Else it's a shorthand.\n\t\t\t\tshorthand = shorthandOrNode\n\t\t\t} else {\n\t\t\t\tshorthand = serializerOrShorthand\n\t\t\t}\n\n\t\t\tlet match:\n\t\t\t\t| DistributedPick<\n\t\t\t\t\t\tRTBlockNode | Exclude<RTInlineNode, RTLabelNode>,\n\t\t\t\t\t\t\"type\"\n\t\t\t\t  >\n\t\t\t\t| { type: \"label\"; data: { label: string } }\n\t\t\tif (typeof shorthand === \"string\") {\n\t\t\t\tmatch = { type: shorthand }\n\t\t\t} else {\n\t\t\t\tmatch = { type: RichTextNodeType.label, data: shorthand }\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tswitch (match.type) {\n\t\t\t\t\tcase RichTextNodeType.heading1:\n\t\t\t\t\tcase RichTextNodeType.heading2:\n\t\t\t\t\tcase RichTextNodeType.heading3:\n\t\t\t\t\tcase RichTextNodeType.heading4:\n\t\t\t\t\tcase RichTextNodeType.heading5:\n\t\t\t\t\tcase RichTextNodeType.heading6:\n\t\t\t\t\tcase RichTextNodeType.paragraph:\n\t\t\t\t\tcase RichTextNodeType.preformatted:\n\t\t\t\t\tcase RichTextNodeType.listItem:\n\t\t\t\t\tcase RichTextNodeType.oListItem:\n\t\t\t\t\t\tlastRTTextNodeType = match.type\n\t\t\t\t\t\tbuilder.appendTextNode(match.type, config?.direction)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase RichTextNodeType.list:\n\t\t\t\t\tcase RichTextNodeType.oList:\n\t\t\t\t\t\tlastListType = match.type\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase RichTextNodeType.image:\n\t\t\t\t\t\tbuilder.appendNode(serializeImage(node))\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase RichTextNodeType.embed:\n\t\t\t\t\t\tbuilder.appendNode(serializeEmbed(node))\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tcase RichTextNodeType.strong:\n\t\t\t\t\tcase RichTextNodeType.em:\n\t\t\t\t\tcase RichTextNodeType.label:\n\t\t\t\t\tcase RichTextNodeType.hyperlink: {\n\t\t\t\t\t\tconst span = serializeSpan(node, match)\n\t\t\t\t\t\tconst length = toString(node).trimEnd().length\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tbuilder.appendSpan(span, length)\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\t// Happens when we extract an image/embed node inside an RTTextNode and that\n\t\t\t\t\t\t\t// the next children is a span. The last RT node type is then an image/embed\n\t\t\t\t\t\t\t// node, so we need to resume a new RT text node.\n\t\t\t\t\t\t\tbuilder.appendTextNode(lastRTTextNodeType, config?.direction)\n\t\t\t\t\t\t\tbuilder.appendSpan(span, length)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Unknown rich text node type: \\`${\n\t\t\t\t\t\t\t\t(match as { type: string }).type\n\t\t\t\t\t\t\t}\\``,\n\t\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tif (error instanceof PrismicRichTextSerializerError) {\n\t\t\t\t\tfile.message(error.message, {\n\t\t\t\t\t\tcause: error,\n\t\t\t\t\t\tplace: node.position,\n\t\t\t\t\t\truleId: VFILE_RULE,\n\t\t\t\t\t\tsource: VFILE_SOURCE,\n\t\t\t\t\t})\n\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tthrow error\n\t\t\t}\n\t\t} else if (node.type === \"text\") {\n\t\t\t// Inspired from `hast-util-whitespace`, see:\n\t\t\t// https://github.com/syntax-tree/hast-util-whitespace/blob/main/lib/index.js\n\t\t\tif (!(node.value.replace(/[ \\t\\n\\f\\r]/g, \"\") === \"\")) {\n\t\t\t\ttry {\n\t\t\t\t\tbuilder.appendText(node.value)\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// Happens when we extract an image/embed node inside an RTTextNode. The last RT\n\t\t\t\t\t// node type is then an image/embed node, so we need to resume a new RT text node.\n\t\t\t\t\tbuilder.appendTextNode(lastRTTextNodeType, config?.direction)\n\t\t\t\t\tbuilder.appendText(node.value)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// We ignore the following node types:\n\t\t// root, doctype, comment, raw\n\t})\n\n\treturn builder.build()\n}\n"],"names":[],"mappings":"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"}