"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const hastUtilSelect = require("hast-util-select");
const rehypeMinifyWhitespace = require("rehype-minify-whitespace");
const unistUtilRemove = require("unist-util-remove");
const unistUtilVisit = require("unist-util-visit");
const filterRichTextField = require("./filterRichTextField.cjs");
const hastToRichText = require("./hastToRichText.cjs");
const rehypeRichText = function rehypeRichText2(config) {
  const self = this;
  self.use(() => {
    return (tree) => {
      if (config == null ? void 0 : config.container) {
        const element = hastUtilSelect.select(config.container, tree);
        if (!element) {
          throw new Error(`No container matching \`${config == null ? void 0 : config.container}\` could be found in the input AST.`);
        }
        tree.children = [element];
      }
      if (config == null ? void 0 : config.exclude) {
        const nodesToExclude = hastUtilSelect.selectAll(config.exclude.join(", "), tree);
        unistUtilRemove.remove(tree, (node) => nodesToExclude.includes(node));
      }
      if (config == null ? void 0 : config.include) {
        const nodesToInclude = [];
        const selector = config.include.join(", ");
        const rawNodesToInclude = hastUtilSelect.selectAll(selector, tree);
        unistUtilVisit.visit(tree, (node) => {
          if (rawNodesToInclude.includes(node)) {
            nodesToInclude.push(node);
            return unistUtilVisit.SKIP;
          }
        });
        tree.children = nodesToInclude;
      }
      if (config == null ? void 0 : config.serializer) {
        for (const key in config.serializer) {
          if (!/^[a-z]+[1-6]?$/.test(key)) {
            const matches = hastUtilSelect.selectAll(key, tree);
            for (let i = 0; i < matches.length; i++) {
              matches[i].matchesSerializer = key;
            }
          }
        }
      }
    };
  });
  self.use(rehypeMinifyWhitespace);
  self.compiler = compiler;
  function compiler(tree, file) {
    const richTextField = hastToRichText.hastToRichText(tree, file, config);
    if (config == null ? void 0 : config.model) {
      return filterRichTextField.filterRichTextField(richTextField, config.model);
    }
    return richTextField;
  }
};
exports.rehypeRichText = rehypeRichText;
//# sourceMappingURL=rehypeRichText.cjs.map
